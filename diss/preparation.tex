\chapter{Preparation}

In this chapter I introduce the changes that I made to my original plan and the more detailed requirements that I decided my implementation should fulfill along with the reasons for doing so. Furthermore, I introduce the elements and workings of Git that were needed to be taken into account as part of the design and the intricacies of programming in OCaml that influenced the structure of the project in a different way to how it may have been written using an imperative or object oriented programming language such as C or Java.

\section{Plan Refinement}

The original plan specified that the project would consist of a git overlay for maildir where filesystem operations would be bundled into commits. It also specified that some possible extensions would be implemented using git's branching model and by parsing emails themselves. To further refine this it was necessary to perform a requirements analysis to decide which features the result would need so that then the implementation strategy could be confirmed.

\subsection{Requirements}

Before starting the project, it was necessary to work out exactly which features needed to be implemented. This was done by performing a requirements analysis. TODO: add requirements analysis

\subsection{Plan modifications and clarifications}

Given the above requirements, further to the initial plan it was decided that it would be useful for the library to also work on standard desktop computers. Therefore it was necessary to also implement a command-line tool to interact with a Gitmaildir. Furthermore, I realised that it would be very useful to have a daemon to synchronise a Gitmaildir with a standard Maildir so this was another feature not in the plan that was to be built in the implementation. Other than these small changes, the plan was otherwise unchanged.

\section{OCaml}

The language of choice for this project was OCaml \cite{MinskyYaron2013RwO}. This is due to it being the language that MirageOS is implemented in and so there were preexisting libraries that were useful for implementing part of the project. OCaml is a primarily functional programming language which also supports imperative and object-oriented programming styles. It also is a member of the ML language family, meaning that it has Hindley-Milner type system.

\subsection{Functional programming}

Although it is possible to use OCaml in an imperative manner, it is not so natural in the language's syntax and all of the libraries that I am using are also written in a functional style so it seemed sensible to continue this into the implementation of Gitmaildir itself.

\subsection{Functors}

An important aspect of OCaml is its module system. At the most basic level, they are simply a nice way to package together a collection of related definitions (these definitions could include data, types and functions). We can also provide signatures for these modules and then have different implementations of modules that satisfy the same signature. This is useful due to functors in OCaml. An OCaml functor is a module that is parametrised by another module. This means that we can pass in a module to a functor and we are returned a new module. This is useful as it means that we can write one implementation depending on a particular module signature and then we can implement multiple back-ends as different modules allowing our original code to work on different systems. In this project it will make it far simpler and less verbose to have Gitmaildir function on both MirageOS, macOS and Linux than it otherwise would be.

\subsection{Monads}

Monads are a design pattern in functional programming languages which allow us to operate on values in a standard manner whilst abstracting away from the specifics of the particular operation. For something to be a monad, it must provide three things (examples given in the syntax of OCaml):

\begin{itemize}
\item A type constructor which builds a monadic type from a given type. \\
      For example \texttt{type 'a t}
\item A type converter which places a type in a monadic type (sometimes called return). \\
      For example \texttt{return : 'a -> 'a t}
\item A combinator which applies a function to an unwrapped monadic value and then returns its result wrapped in a monad (often called bind). \\
      For example \texttt{val (>>=) : 'a t -> ('a -> 'b t) -> 'b t}
\end{itemize}

Along with these three elements, a monad must obey three laws:

\begin{itemize}
\item return is a left-identity for bind: \\
      \texttt{return x >>= f} \texttt{f x}
\item return is a right-identity for bind: \\
      \texttt{m >>= return} \texttt{m}
\item bind is associative: \\
      \texttt{(m >>= f) >>= g} \texttt{m >>= (fun x -> f x >>= g)}
\end{itemize}

Monads can have multiple uses. For example in Haskell they are used for everything that causes side effects such as io operations. In OCaml they are not a built-in part of the language but that does not mean they do not get used. A library used heavily in my project is lwt \cite{lwt_library} which provides promises in the form of a concurrency monad. It was a necessary part of interacting with ocaml-git but also is of further use as it allows building up operations to be later executed concurrently \footnote{This is not quite true as OCaml is still inherently single-threaded, but will soon have multicore support with ocaml-multicore \cite{ocaml-multicore}}.

\section{Git}

Git is a well know, widely used distributed version-control system. Its main and original use was for programmers to use as a version-control system for their software. It is implemented on top of a Content-Addressable Storage system, and provides the primitives needed for version control as commands that act on this. As it provides version control it can be used to implement strong consistency which is why I chose to use it for the project. Therefore it was important to understand the internals so that I could interface with it correctly.

\subsection{Content-Addressable Storage}

A content-addressable storage system is, exactly as the name describes, a storage system where each object is addressed by its content in some way. This is different to most storage systems which tend to be location-addressed where the index need-not have any relation to the data it points to (ie we can name a file anything regardless of its content). This is implemented in git using hash functions. It works, by storing data on the filesystem as standard, except the file name is always a hash of the contents of the file itself. The reason this is used is then the entire version control can just be implemented as a form of hash chain, and because the file names derive from their contents we can always be sure that a file is the correct historic copy because a small change in its contents will cause a large change in its name. 

\subsection{Porcelain and Plumbing}

Git has two sets of command-line tools: its ``porcelain'' tools and its ``plumbing'' tools. The important difference is that the porcelain tools are the ones that users of the version control system should use for all normal operations, but the plumbing tools are lower level and allow direct interaction with the git store. As I am using the git store in slightly non-standard ways, it was important to learn the plumbing commands so that I can use the full power of the git storage system while simultaneously leaving the git store in a valid state after each operation.

\section{ocaml-git}

Ocaml-git \cite{ocaml-git} is a library that the project relies on heavily. It is a complete reimplementation of the git specification in OCaml, meaning that it relies on none of the original git code-base. This is very useful as it provides immediate interoperability with my code rather than having to write wrappers for shell scripts whenever I wish to interact with the git store. However, it is much lower level in terms of what it offers than the git command-line interface. It offers types and modules that allow reading, writing and modifying any type of git object in a git store. It also offers some interaction with the index. However, it does not add any more which means that any features of the git porcelain commands must be reimplemented if I wish to use them and even quite a few of the operations that plumbing commands offer. As a means of interacting with git stores without having to worry about their layout on disk so that I can focus on functionality it will be indispensable.

\section{Maildir}

As I had chosen Maildir as the kind of mail storage I was going to model, it was important to find out its exact specification in terms of structure and interaction. Maildirs are in fact incredibly simple. Each email is stored as a separate file with a unique name. These emails are store in one of three directories:

\begin{itemize}
\item \texttt{tmp}: Emails are stored here while being delivered
\item \texttt{new}: Emails that have been delivered but not read are stored here
\item \texttt{cur}: All other emails are stored here
\end{itemize}

Also, flags can be added to the end of email filenames to provide extra metadata such as if an email has been flagged. There are also many extensions to the standard providing extra features such as notation for separate email directories. Furthermore, there are specific rules about the structure of the names and how the randomness should be generated for them to provide enough safety from name collisions. Also there are rules about how exactly an email should be delivered to the directory to be safer in concurrent situations. All these had to be taken into account for the implementation, but given the new storage structure, so of the rules proved irrelevant and some other changes did have to be made.
